// @generated by protobuf-ts 2.9.3
// @generated from protobuf file "proto.proto" (package "rustplus", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message rustplus.Vector2
 */
export interface Vector2 {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
}
/**
 * @generated from protobuf message rustplus.Vector3
 */
export interface Vector3 {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
}
/**
 * @generated from protobuf message rustplus.Vector4
 */
export interface Vector4 {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
    /**
     * @generated from protobuf field: optional float w = 4;
     */
    w?: number;
}
/**
 * @generated from protobuf message rustplus.Half3
 */
export interface Half3 {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
}
/**
 * @generated from protobuf message rustplus.Color
 */
export interface Color {
    /**
     * @generated from protobuf field: optional float r = 1;
     */
    r?: number;
    /**
     * @generated from protobuf field: optional float g = 2;
     */
    g?: number;
    /**
     * @generated from protobuf field: optional float b = 3;
     */
    b?: number;
    /**
     * @generated from protobuf field: optional float a = 4;
     */
    a?: number;
}
/**
 * @generated from protobuf message rustplus.Ray
 */
export interface Ray {
    /**
     * @generated from protobuf field: optional rustplus.Vector3 origin = 1;
     */
    origin?: Vector3;
    /**
     * @generated from protobuf field: optional rustplus.Vector3 direction = 2;
     */
    direction?: Vector3;
}
/**
 * @generated from protobuf message rustplus.ClanActionResult
 */
export interface ClanActionResult {
    /**
     * @generated from protobuf field: int32 requestId = 1;
     */
    requestId: number;
    /**
     * @generated from protobuf field: int32 result = 2;
     */
    result: number;
    /**
     * @generated from protobuf field: bool hasClanInfo = 3;
     */
    hasClanInfo: boolean;
    /**
     * @generated from protobuf field: optional rustplus.ClanInfo clanInfo = 4;
     */
    clanInfo?: ClanInfo;
}
/**
 * @generated from protobuf message rustplus.ClanInfo
 */
export interface ClanInfo {
    /**
     * @generated from protobuf field: int64 clanId = 1;
     */
    clanId: bigint;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: int64 created = 3;
     */
    created: bigint;
    /**
     * @generated from protobuf field: uint64 creator = 4;
     */
    creator: bigint;
    /**
     * @generated from protobuf field: optional string motd = 5;
     */
    motd?: string;
    /**
     * @generated from protobuf field: optional int64 motdTimestamp = 6;
     */
    motdTimestamp?: bigint;
    /**
     * @generated from protobuf field: optional uint64 motdAuthor = 7;
     */
    motdAuthor?: bigint;
    /**
     * @generated from protobuf field: optional bytes logo = 8;
     */
    logo?: Uint8Array;
    /**
     * @generated from protobuf field: optional sint32 color = 9;
     */
    color?: number;
    /**
     * @generated from protobuf field: repeated rustplus.ClanInfo.Role roles = 10;
     */
    roles: ClanInfo_Role[];
    /**
     * @generated from protobuf field: repeated rustplus.ClanInfo.Member members = 11;
     */
    members: ClanInfo_Member[];
    /**
     * @generated from protobuf field: repeated rustplus.ClanInfo.Invite invites = 12;
     */
    invites: ClanInfo_Invite[];
    /**
     * @generated from protobuf field: optional int32 maxMemberCount = 13;
     */
    maxMemberCount?: number;
}
/**
 * @generated from protobuf message rustplus.ClanInfo.Role
 */
export interface ClanInfo_Role {
    /**
     * @generated from protobuf field: int32 roleId = 1;
     */
    roleId: number;
    /**
     * @generated from protobuf field: int32 rank = 2;
     */
    rank: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: bool canSetMotd = 4;
     */
    canSetMotd: boolean;
    /**
     * @generated from protobuf field: bool canSetLogo = 5;
     */
    canSetLogo: boolean;
    /**
     * @generated from protobuf field: bool canInvite = 6;
     */
    canInvite: boolean;
    /**
     * @generated from protobuf field: bool canKick = 7;
     */
    canKick: boolean;
    /**
     * @generated from protobuf field: bool canPromote = 8;
     */
    canPromote: boolean;
    /**
     * @generated from protobuf field: bool canDemote = 9;
     */
    canDemote: boolean;
    /**
     * @generated from protobuf field: bool canSetPlayerNotes = 10;
     */
    canSetPlayerNotes: boolean;
    /**
     * @generated from protobuf field: bool canAccessLogs = 11;
     */
    canAccessLogs: boolean;
}
/**
 * @generated from protobuf message rustplus.ClanInfo.Member
 */
export interface ClanInfo_Member {
    /**
     * @generated from protobuf field: uint64 steamId = 1;
     */
    steamId: bigint;
    /**
     * @generated from protobuf field: int32 roleId = 2;
     */
    roleId: number;
    /**
     * @generated from protobuf field: int64 joined = 3;
     */
    joined: bigint;
    /**
     * @generated from protobuf field: int64 lastSeen = 4;
     */
    lastSeen: bigint;
    /**
     * @generated from protobuf field: optional string notes = 5;
     */
    notes?: string;
    /**
     * @generated from protobuf field: optional bool online = 6;
     */
    online?: boolean;
}
/**
 * @generated from protobuf message rustplus.ClanInfo.Invite
 */
export interface ClanInfo_Invite {
    /**
     * @generated from protobuf field: uint64 steamId = 1;
     */
    steamId: bigint;
    /**
     * @generated from protobuf field: uint64 recruiter = 2;
     */
    recruiter: bigint;
    /**
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message rustplus.ClanLog
 */
export interface ClanLog {
    /**
     * @generated from protobuf field: int64 clanId = 1;
     */
    clanId: bigint;
    /**
     * @generated from protobuf field: repeated rustplus.ClanLog.Entry logEntries = 2;
     */
    logEntries: ClanLog_Entry[];
}
/**
 * @generated from protobuf message rustplus.ClanLog.Entry
 */
export interface ClanLog_Entry {
    /**
     * @generated from protobuf field: int64 timestamp = 1;
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: string eventKey = 2;
     */
    eventKey: string;
    /**
     * @generated from protobuf field: optional string arg1 = 3;
     */
    arg1?: string;
    /**
     * @generated from protobuf field: optional string arg2 = 4;
     */
    arg2?: string;
    /**
     * @generated from protobuf field: optional string arg3 = 5;
     */
    arg3?: string;
    /**
     * @generated from protobuf field: optional string arg4 = 6;
     */
    arg4?: string;
}
/**
 * @generated from protobuf message rustplus.ClanInvitations
 */
export interface ClanInvitations {
    /**
     * @generated from protobuf field: repeated rustplus.ClanInvitations.Invitation invitations = 1;
     */
    invitations: ClanInvitations_Invitation[];
}
/**
 * @generated from protobuf message rustplus.ClanInvitations.Invitation
 */
export interface ClanInvitations_Invitation {
    /**
     * @generated from protobuf field: int64 clanId = 1;
     */
    clanId: bigint;
    /**
     * @generated from protobuf field: uint64 recruiter = 2;
     */
    recruiter: bigint;
    /**
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message rustplus.AppRequest
 */
export interface AppRequest {
    /**
     * @generated from protobuf field: uint32 seq = 1;
     */
    seq: number;
    /**
     * @generated from protobuf field: uint64 playerId = 2;
     */
    playerId: bigint;
    /**
     * @generated from protobuf field: int32 playerToken = 3;
     */
    playerToken: number;
    /**
     * @generated from protobuf field: optional uint32 entityId = 4;
     */
    entityId?: number;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getInfo = 8;
     */
    getInfo?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getTime = 9;
     */
    getTime?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getMap = 10;
     */
    getMap?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getTeamInfo = 11;
     */
    getTeamInfo?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getTeamChat = 12;
     */
    getTeamChat?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppSendMessage sendTeamMessage = 13;
     */
    sendTeamMessage?: AppSendMessage;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getEntityInfo = 14;
     */
    getEntityInfo?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppSetEntityValue setEntityValue = 15;
     */
    setEntityValue?: AppSetEntityValue;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty checkSubscription = 16;
     */
    checkSubscription?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppFlag setSubscription = 17;
     */
    setSubscription?: AppFlag;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getMapMarkers = 18;
     */
    getMapMarkers?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppPromoteToLeader promoteToLeader = 20;
     */
    promoteToLeader?: AppPromoteToLeader;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getClanInfo = 21;
     */
    getClanInfo?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppSendMessage setClanMotd = 22;
     */
    setClanMotd?: AppSendMessage;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty getClanChat = 23;
     */
    getClanChat?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppSendMessage sendClanMessage = 24;
     */
    sendClanMessage?: AppSendMessage;
    /**
     * @generated from protobuf field: optional rustplus.AppGetNexusAuth getNexusAuth = 25;
     */
    getNexusAuth?: AppGetNexusAuth;
    /**
     * @generated from protobuf field: optional rustplus.AppCameraSubscribe cameraSubscribe = 30;
     */
    cameraSubscribe?: AppCameraSubscribe;
    /**
     * @generated from protobuf field: optional rustplus.AppEmpty cameraUnsubscribe = 31;
     */
    cameraUnsubscribe?: AppEmpty;
    /**
     * @generated from protobuf field: optional rustplus.AppCameraInput cameraInput = 32;
     */
    cameraInput?: AppCameraInput;
}
/**
 * @generated from protobuf message rustplus.AppMessage
 */
export interface AppMessage {
    /**
     * @generated from protobuf field: optional rustplus.AppResponse response = 1;
     */
    response?: AppResponse;
    /**
     * @generated from protobuf field: optional rustplus.AppBroadcast broadcast = 2;
     */
    broadcast?: AppBroadcast;
}
/**
 * @generated from protobuf message rustplus.AppResponse
 */
export interface AppResponse {
    /**
     * @generated from protobuf field: uint32 seq = 1;
     */
    seq: number;
    /**
     * @generated from protobuf field: optional rustplus.AppSuccess success = 4;
     */
    success?: AppSuccess;
    /**
     * @generated from protobuf field: optional rustplus.AppError error = 5;
     */
    error?: AppError;
    /**
     * @generated from protobuf field: optional rustplus.AppInfo info = 6;
     */
    info?: AppInfo;
    /**
     * @generated from protobuf field: optional rustplus.AppTime time = 7;
     */
    time?: AppTime;
    /**
     * @generated from protobuf field: optional rustplus.AppMap map = 8;
     */
    map?: AppMap;
    /**
     * @generated from protobuf field: optional rustplus.AppTeamInfo teamInfo = 9;
     */
    teamInfo?: AppTeamInfo;
    /**
     * @generated from protobuf field: optional rustplus.AppTeamChat teamChat = 10;
     */
    teamChat?: AppTeamChat;
    /**
     * @generated from protobuf field: optional rustplus.AppEntityInfo entityInfo = 11;
     */
    entityInfo?: AppEntityInfo;
    /**
     * @generated from protobuf field: optional rustplus.AppFlag flag = 12;
     */
    flag?: AppFlag;
    /**
     * @generated from protobuf field: optional rustplus.AppMapMarkers mapMarkers = 13;
     */
    mapMarkers?: AppMapMarkers;
    /**
     * @generated from protobuf field: optional rustplus.AppClanInfo clanInfo = 15;
     */
    clanInfo?: AppClanInfo;
    /**
     * @generated from protobuf field: optional rustplus.AppClanChat clanChat = 16;
     */
    clanChat?: AppClanChat;
    /**
     * @generated from protobuf field: optional rustplus.AppNexusAuth nexusAuth = 17;
     */
    nexusAuth?: AppNexusAuth;
    /**
     * @generated from protobuf field: optional rustplus.AppCameraInfo cameraSubscribeInfo = 20;
     */
    cameraSubscribeInfo?: AppCameraInfo;
}
/**
 * @generated from protobuf message rustplus.AppBroadcast
 */
export interface AppBroadcast {
    /**
     * @generated from protobuf field: optional rustplus.AppTeamChanged teamChanged = 4;
     */
    teamChanged?: AppTeamChanged;
    /**
     * @generated from protobuf field: optional rustplus.AppNewTeamMessage teamMessage = 5;
     */
    teamMessage?: AppNewTeamMessage;
    /**
     * @generated from protobuf field: optional rustplus.AppEntityChanged entityChanged = 6;
     */
    entityChanged?: AppEntityChanged;
    /**
     * @generated from protobuf field: optional rustplus.AppClanChanged clanChanged = 7;
     */
    clanChanged?: AppClanChanged;
    /**
     * @generated from protobuf field: optional rustplus.AppNewClanMessage clanMessage = 8;
     */
    clanMessage?: AppNewClanMessage;
    /**
     * @generated from protobuf field: optional rustplus.AppCameraRays cameraRays = 10;
     */
    cameraRays?: AppCameraRays;
}
/**
 * @generated from protobuf message rustplus.AppEmpty
 */
export interface AppEmpty {
}
/**
 * @generated from protobuf message rustplus.AppSendMessage
 */
export interface AppSendMessage {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message rustplus.AppSetEntityValue
 */
export interface AppSetEntityValue {
    /**
     * @generated from protobuf field: bool value = 1;
     */
    value: boolean;
}
/**
 * @generated from protobuf message rustplus.AppPromoteToLeader
 */
export interface AppPromoteToLeader {
    /**
     * @generated from protobuf field: uint64 steamId = 1;
     */
    steamId: bigint;
}
/**
 * @generated from protobuf message rustplus.AppGetNexusAuth
 */
export interface AppGetNexusAuth {
    /**
     * @generated from protobuf field: string appKey = 1;
     */
    appKey: string;
}
/**
 * @generated from protobuf message rustplus.AppSuccess
 */
export interface AppSuccess {
}
/**
 * @generated from protobuf message rustplus.AppError
 */
export interface AppError {
    /**
     * @generated from protobuf field: string error = 1;
     */
    error: string;
}
/**
 * @generated from protobuf message rustplus.AppFlag
 */
export interface AppFlag {
    /**
     * @generated from protobuf field: bool value = 1;
     */
    value: boolean;
}
/**
 * @generated from protobuf message rustplus.AppInfo
 */
export interface AppInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string headerImage = 2;
     */
    headerImage: string;
    /**
     * @generated from protobuf field: string url = 3;
     */
    url: string;
    /**
     * @generated from protobuf field: string map = 4;
     */
    map: string;
    /**
     * @generated from protobuf field: uint32 mapSize = 5;
     */
    mapSize: number;
    /**
     * @generated from protobuf field: uint32 wipeTime = 6;
     */
    wipeTime: number;
    /**
     * @generated from protobuf field: uint32 players = 7;
     */
    players: number;
    /**
     * @generated from protobuf field: uint32 maxPlayers = 8;
     */
    maxPlayers: number;
    /**
     * @generated from protobuf field: uint32 queuedPlayers = 9;
     */
    queuedPlayers: number;
    /**
     * @generated from protobuf field: optional uint32 seed = 10;
     */
    seed?: number;
    /**
     * @generated from protobuf field: optional uint32 salt = 11;
     */
    salt?: number;
    /**
     * @generated from protobuf field: optional string logoImage = 12;
     */
    logoImage?: string;
    /**
     * @generated from protobuf field: optional string nexus = 13;
     */
    nexus?: string;
    /**
     * @generated from protobuf field: optional int32 nexusId = 14;
     */
    nexusId?: number;
    /**
     * @generated from protobuf field: optional string nexusZone = 15;
     */
    nexusZone?: string;
}
/**
 * @generated from protobuf message rustplus.AppTime
 */
export interface AppTime {
    /**
     * @generated from protobuf field: float dayLengthMinutes = 1;
     */
    dayLengthMinutes: number;
    /**
     * @generated from protobuf field: float timeScale = 2;
     */
    timeScale: number;
    /**
     * @generated from protobuf field: float sunrise = 3;
     */
    sunrise: number;
    /**
     * @generated from protobuf field: float sunset = 4;
     */
    sunset: number;
    /**
     * @generated from protobuf field: float time = 5;
     */
    time: number;
}
/**
 * @generated from protobuf message rustplus.AppMap
 */
export interface AppMap {
    /**
     * @generated from protobuf field: uint32 width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 2;
     */
    height: number;
    /**
     * @generated from protobuf field: bytes jpgImage = 3;
     */
    jpgImage: Uint8Array;
    /**
     * @generated from protobuf field: int32 oceanMargin = 4;
     */
    oceanMargin: number;
    /**
     * @generated from protobuf field: repeated rustplus.AppMap.Monument monuments = 5;
     */
    monuments: AppMap_Monument[];
    /**
     * @generated from protobuf field: optional string background = 6;
     */
    background?: string;
}
/**
 * @generated from protobuf message rustplus.AppMap.Monument
 */
export interface AppMap_Monument {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number;
}
/**
 * @generated from protobuf message rustplus.AppEntityInfo
 */
export interface AppEntityInfo {
    /**
     * @generated from protobuf field: rustplus.AppEntityType type = 1;
     */
    type: AppEntityType;
    /**
     * @generated from protobuf field: rustplus.AppEntityPayload payload = 3;
     */
    payload?: AppEntityPayload;
}
/**
 * @generated from protobuf message rustplus.AppEntityPayload
 */
export interface AppEntityPayload {
    /**
     * @generated from protobuf field: optional bool value = 1;
     */
    value?: boolean;
    /**
     * @generated from protobuf field: repeated rustplus.AppEntityPayload.Item items = 2;
     */
    items: AppEntityPayload_Item[];
    /**
     * @generated from protobuf field: optional int32 capacity = 3;
     */
    capacity?: number;
    /**
     * @generated from protobuf field: optional bool hasProtection = 4;
     */
    hasProtection?: boolean;
    /**
     * @generated from protobuf field: optional uint32 protectionExpiry = 5;
     */
    protectionExpiry?: number;
}
/**
 * @generated from protobuf message rustplus.AppEntityPayload.Item
 */
export interface AppEntityPayload_Item {
    /**
     * @generated from protobuf field: int32 itemId = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: int32 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: bool itemIsBlueprint = 3;
     */
    itemIsBlueprint: boolean;
}
/**
 * @generated from protobuf message rustplus.AppTeamInfo
 */
export interface AppTeamInfo {
    /**
     * @generated from protobuf field: uint64 leaderSteamId = 1;
     */
    leaderSteamId: bigint;
    /**
     * @generated from protobuf field: repeated rustplus.AppTeamInfo.Member members = 2;
     */
    members: AppTeamInfo_Member[];
    /**
     * @generated from protobuf field: repeated rustplus.AppTeamInfo.Note mapNotes = 3;
     */
    mapNotes: AppTeamInfo_Note[];
    /**
     * @generated from protobuf field: repeated rustplus.AppTeamInfo.Note leaderMapNotes = 4;
     */
    leaderMapNotes: AppTeamInfo_Note[];
}
/**
 * @generated from protobuf message rustplus.AppTeamInfo.Member
 */
export interface AppTeamInfo_Member {
    /**
     * @generated from protobuf field: uint64 steamId = 1;
     */
    steamId: bigint;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
    /**
     * @generated from protobuf field: bool isOnline = 5;
     */
    isOnline: boolean;
    /**
     * @generated from protobuf field: uint32 spawnTime = 6;
     */
    spawnTime: number;
    /**
     * @generated from protobuf field: bool isAlive = 7;
     */
    isAlive: boolean;
    /**
     * @generated from protobuf field: uint32 deathTime = 8;
     */
    deathTime: number;
}
/**
 * @generated from protobuf message rustplus.AppTeamInfo.Note
 */
export interface AppTeamInfo_Note {
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
}
/**
 * @generated from protobuf message rustplus.AppTeamMessage
 */
export interface AppTeamMessage {
    /**
     * @generated from protobuf field: uint64 steamId = 1;
     */
    steamId: bigint;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: string color = 4;
     */
    color: string;
    /**
     * @generated from protobuf field: uint32 time = 5;
     */
    time: number;
}
/**
 * @generated from protobuf message rustplus.AppTeamChat
 */
export interface AppTeamChat {
    /**
     * @generated from protobuf field: repeated rustplus.AppTeamMessage messages = 1;
     */
    messages: AppTeamMessage[];
}
/**
 * @generated from protobuf message rustplus.AppMarker
 */
export interface AppMarker {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: rustplus.AppMarkerType type = 2;
     */
    type: AppMarkerType;
    /**
     * @generated from protobuf field: float x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 4;
     */
    y: number;
    /**
     * @generated from protobuf field: optional uint64 steamId = 5;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional float rotation = 6;
     */
    rotation?: number;
    /**
     * @generated from protobuf field: optional float radius = 7;
     */
    radius?: number;
    /**
     * @generated from protobuf field: optional rustplus.Vector4 color1 = 8;
     */
    color1?: Vector4;
    /**
     * @generated from protobuf field: optional rustplus.Vector4 color2 = 9;
     */
    color2?: Vector4;
    /**
     * @generated from protobuf field: optional float alpha = 10;
     */
    alpha?: number;
    /**
     * @generated from protobuf field: optional string name = 11;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional bool outOfStock = 12;
     */
    outOfStock?: boolean;
    /**
     * @generated from protobuf field: repeated rustplus.AppMarker.SellOrder sellOrders = 13;
     */
    sellOrders: AppMarker_SellOrder[];
}
/**
 * @generated from protobuf message rustplus.AppMarker.SellOrder
 */
export interface AppMarker_SellOrder {
    /**
     * @generated from protobuf field: int32 itemId = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: int32 quantity = 2;
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 currencyId = 3;
     */
    currencyId: number;
    /**
     * @generated from protobuf field: int32 costPerItem = 4;
     */
    costPerItem: number;
    /**
     * @generated from protobuf field: int32 amountInStock = 5;
     */
    amountInStock: number;
    /**
     * @generated from protobuf field: bool itemIsBlueprint = 6;
     */
    itemIsBlueprint: boolean;
    /**
     * @generated from protobuf field: bool currencyIsBlueprint = 7;
     */
    currencyIsBlueprint: boolean;
    /**
     * @generated from protobuf field: optional float itemCondition = 8;
     */
    itemCondition?: number;
    /**
     * @generated from protobuf field: optional float itemConditionMax = 9;
     */
    itemConditionMax?: number;
}
/**
 * @generated from protobuf message rustplus.AppMapMarkers
 */
export interface AppMapMarkers {
    /**
     * @generated from protobuf field: repeated rustplus.AppMarker markers = 1;
     */
    markers: AppMarker[];
}
/**
 * @generated from protobuf message rustplus.AppClanInfo
 */
export interface AppClanInfo {
    /**
     * @generated from protobuf field: optional rustplus.ClanInfo clanInfo = 1;
     */
    clanInfo?: ClanInfo;
}
/**
 * @generated from protobuf message rustplus.AppClanMessage
 */
export interface AppClanMessage {
    /**
     * @generated from protobuf field: uint64 steamId = 1;
     */
    steamId: bigint;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: int64 time = 4;
     */
    time: bigint;
}
/**
 * @generated from protobuf message rustplus.AppClanChat
 */
export interface AppClanChat {
    /**
     * @generated from protobuf field: repeated rustplus.AppClanMessage messages = 1;
     */
    messages: AppClanMessage[];
}
/**
 * @generated from protobuf message rustplus.AppNexusAuth
 */
export interface AppNexusAuth {
    /**
     * @generated from protobuf field: string serverId = 1;
     */
    serverId: string;
    /**
     * @generated from protobuf field: int32 playerToken = 2;
     */
    playerToken: number;
}
/**
 * @generated from protobuf message rustplus.AppTeamChanged
 */
export interface AppTeamChanged {
    /**
     * @generated from protobuf field: uint64 playerId = 1;
     */
    playerId: bigint;
    /**
     * @generated from protobuf field: rustplus.AppTeamInfo teamInfo = 2;
     */
    teamInfo?: AppTeamInfo;
}
/**
 * @generated from protobuf message rustplus.AppNewTeamMessage
 */
export interface AppNewTeamMessage {
    /**
     * @generated from protobuf field: rustplus.AppTeamMessage message = 1;
     */
    message?: AppTeamMessage;
}
/**
 * @generated from protobuf message rustplus.AppEntityChanged
 */
export interface AppEntityChanged {
    /**
     * @generated from protobuf field: uint32 entityId = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: rustplus.AppEntityPayload payload = 2;
     */
    payload?: AppEntityPayload;
}
/**
 * @generated from protobuf message rustplus.AppClanChanged
 */
export interface AppClanChanged {
    /**
     * @generated from protobuf field: optional rustplus.ClanInfo clanInfo = 1;
     */
    clanInfo?: ClanInfo;
}
/**
 * @generated from protobuf message rustplus.AppNewClanMessage
 */
export interface AppNewClanMessage {
    /**
     * @generated from protobuf field: int64 clanId = 1;
     */
    clanId: bigint;
    /**
     * @generated from protobuf field: rustplus.AppClanMessage message = 2;
     */
    message?: AppClanMessage;
}
/**
 * @generated from protobuf message rustplus.AppCameraSubscribe
 */
export interface AppCameraSubscribe {
    /**
     * @generated from protobuf field: string cameraId = 1;
     */
    cameraId: string;
}
/**
 * @generated from protobuf message rustplus.AppCameraInput
 */
export interface AppCameraInput {
    /**
     * @generated from protobuf field: int32 buttons = 1;
     */
    buttons: number;
    /**
     * @generated from protobuf field: rustplus.Vector2 mouseDelta = 2;
     */
    mouseDelta?: Vector2;
}
/**
 * @generated from protobuf message rustplus.AppCameraInfo
 */
export interface AppCameraInfo {
    /**
     * @generated from protobuf field: int32 width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 2;
     */
    height: number;
    /**
     * @generated from protobuf field: float nearPlane = 3;
     */
    nearPlane: number;
    /**
     * @generated from protobuf field: float farPlane = 4;
     */
    farPlane: number;
    /**
     * @generated from protobuf field: int32 controlFlags = 5;
     */
    controlFlags: number;
}
/**
 * @generated from protobuf message rustplus.AppCameraRays
 */
export interface AppCameraRays {
    /**
     * @generated from protobuf field: float verticalFov = 1;
     */
    verticalFov: number;
    /**
     * @generated from protobuf field: int32 sampleOffset = 2;
     */
    sampleOffset: number;
    /**
     * @generated from protobuf field: bytes rayData = 3;
     */
    rayData: Uint8Array;
    /**
     * @generated from protobuf field: float distance = 4;
     */
    distance: number;
    /**
     * @generated from protobuf field: repeated rustplus.AppCameraRays.Entity entities = 5;
     */
    entities: AppCameraRays_Entity[];
}
/**
 * @generated from protobuf message rustplus.AppCameraRays.Entity
 */
export interface AppCameraRays_Entity {
    /**
     * @generated from protobuf field: uint32 entityId = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: rustplus.AppCameraRays.EntityType type = 2;
     */
    type: AppCameraRays_EntityType;
    /**
     * @generated from protobuf field: rustplus.Vector3 position = 3;
     */
    position?: Vector3;
    /**
     * @generated from protobuf field: rustplus.Vector3 rotation = 4;
     */
    rotation?: Vector3;
    /**
     * @generated from protobuf field: rustplus.Vector3 size = 5;
     */
    size?: Vector3;
    /**
     * @generated from protobuf field: optional string name = 6;
     */
    name?: string;
}
/**
 * @generated from protobuf enum rustplus.AppCameraRays.EntityType
 */
export enum AppCameraRays_EntityType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: Tree = 1;
     */
    Tree = 1,
    /**
     * @generated from protobuf enum value: Player = 2;
     */
    Player = 2
}
/**
 * @generated from protobuf enum rustplus.AppEntityType
 */
export enum AppEntityType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: Switch = 1;
     */
    Switch = 1,
    /**
     * @generated from protobuf enum value: Alarm = 2;
     */
    Alarm = 2,
    /**
     * @generated from protobuf enum value: StorageMonitor = 3;
     */
    StorageMonitor = 3
}
/**
 * @generated from protobuf enum rustplus.AppMarkerType
 */
export enum AppMarkerType {
    /**
     * @generated from protobuf enum value: Undefined = 0;
     */
    Undefined = 0,
    /**
     * @generated from protobuf enum value: Player = 1;
     */
    Player = 1,
    /**
     * @generated from protobuf enum value: Explosion = 2;
     */
    Explosion = 2,
    /**
     * @generated from protobuf enum value: VendingMachine = 3;
     */
    VendingMachine = 3,
    /**
     * @generated from protobuf enum value: CH47 = 4;
     */
    CH47 = 4,
    /**
     * @generated from protobuf enum value: CargoShip = 5;
     */
    CargoShip = 5,
    /**
     * @generated from protobuf enum value: Crate = 6;
     */
    Crate = 6,
    /**
     * @generated from protobuf enum value: GenericRadius = 7;
     */
    GenericRadius = 7,
    /**
     * @generated from protobuf enum value: PatrolHelicopter = 8;
     */
    PatrolHelicopter = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class Vector2$Type extends MessageType<Vector2> {
    constructor() {
        super("rustplus.Vector2", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Vector2>): Vector2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Vector2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector2): Vector2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.Vector2
 */
export const Vector2 = new Vector2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector3$Type extends MessageType<Vector3> {
    constructor() {
        super("rustplus.Vector3", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Vector3>): Vector3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Vector3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector3): Vector3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.Vector3
 */
export const Vector3 = new Vector3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector4$Type extends MessageType<Vector4> {
    constructor() {
        super("rustplus.Vector4", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "w", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Vector4>): Vector4 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Vector4>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector4): Vector4 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                case /* optional float w */ 4:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector4, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        /* optional float w = 4; */
        if (message.w !== undefined)
            writer.tag(4, WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.Vector4
 */
export const Vector4 = new Vector4$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Half3$Type extends MessageType<Half3> {
    constructor() {
        super("rustplus.Half3", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Half3>): Half3 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Half3>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Half3): Half3 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Half3, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.Half3
 */
export const Half3 = new Half3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Color$Type extends MessageType<Color> {
    constructor() {
        super("rustplus.Color", [
            { no: 1, name: "r", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "g", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "b", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "a", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Color>): Color {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Color>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Color): Color {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float r */ 1:
                    message.r = reader.float();
                    break;
                case /* optional float g */ 2:
                    message.g = reader.float();
                    break;
                case /* optional float b */ 3:
                    message.b = reader.float();
                    break;
                case /* optional float a */ 4:
                    message.a = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Color, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float r = 1; */
        if (message.r !== undefined)
            writer.tag(1, WireType.Bit32).float(message.r);
        /* optional float g = 2; */
        if (message.g !== undefined)
            writer.tag(2, WireType.Bit32).float(message.g);
        /* optional float b = 3; */
        if (message.b !== undefined)
            writer.tag(3, WireType.Bit32).float(message.b);
        /* optional float a = 4; */
        if (message.a !== undefined)
            writer.tag(4, WireType.Bit32).float(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.Color
 */
export const Color = new Color$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ray$Type extends MessageType<Ray> {
    constructor() {
        super("rustplus.Ray", [
            { no: 1, name: "origin", kind: "message", T: () => Vector3 },
            { no: 2, name: "direction", kind: "message", T: () => Vector3 }
        ]);
    }
    create(value?: PartialMessage<Ray>): Ray {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Ray>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ray): Ray {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional rustplus.Vector3 origin */ 1:
                    message.origin = Vector3.internalBinaryRead(reader, reader.uint32(), options, message.origin);
                    break;
                case /* optional rustplus.Vector3 direction */ 2:
                    message.direction = Vector3.internalBinaryRead(reader, reader.uint32(), options, message.direction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ray, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional rustplus.Vector3 origin = 1; */
        if (message.origin)
            Vector3.internalBinaryWrite(message.origin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.Vector3 direction = 2; */
        if (message.direction)
            Vector3.internalBinaryWrite(message.direction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.Ray
 */
export const Ray = new Ray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanActionResult$Type extends MessageType<ClanActionResult> {
    constructor() {
        super("rustplus.ClanActionResult", [
            { no: 1, name: "requestId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "result", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hasClanInfo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "clanInfo", kind: "message", T: () => ClanInfo }
        ]);
    }
    create(value?: PartialMessage<ClanActionResult>): ClanActionResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestId = 0;
        message.result = 0;
        message.hasClanInfo = false;
        if (value !== undefined)
            reflectionMergePartial<ClanActionResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanActionResult): ClanActionResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 requestId */ 1:
                    message.requestId = reader.int32();
                    break;
                case /* int32 result */ 2:
                    message.result = reader.int32();
                    break;
                case /* bool hasClanInfo */ 3:
                    message.hasClanInfo = reader.bool();
                    break;
                case /* optional rustplus.ClanInfo clanInfo */ 4:
                    message.clanInfo = ClanInfo.internalBinaryRead(reader, reader.uint32(), options, message.clanInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanActionResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 requestId = 1; */
        if (message.requestId !== 0)
            writer.tag(1, WireType.Varint).int32(message.requestId);
        /* int32 result = 2; */
        if (message.result !== 0)
            writer.tag(2, WireType.Varint).int32(message.result);
        /* bool hasClanInfo = 3; */
        if (message.hasClanInfo !== false)
            writer.tag(3, WireType.Varint).bool(message.hasClanInfo);
        /* optional rustplus.ClanInfo clanInfo = 4; */
        if (message.clanInfo)
            ClanInfo.internalBinaryWrite(message.clanInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanActionResult
 */
export const ClanActionResult = new ClanActionResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanInfo$Type extends MessageType<ClanInfo> {
    constructor() {
        super("rustplus.ClanInfo", [
            { no: 1, name: "clanId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "creator", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "motd", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "motdTimestamp", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "motdAuthor", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "logo", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "color", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 10, name: "roles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClanInfo_Role },
            { no: 11, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClanInfo_Member },
            { no: 12, name: "invites", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClanInfo_Invite },
            { no: 13, name: "maxMemberCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClanInfo>): ClanInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clanId = 0n;
        message.name = "";
        message.created = 0n;
        message.creator = 0n;
        message.roles = [];
        message.members = [];
        message.invites = [];
        if (value !== undefined)
            reflectionMergePartial<ClanInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanInfo): ClanInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 clanId */ 1:
                    message.clanId = reader.int64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 created */ 3:
                    message.created = reader.int64().toBigInt();
                    break;
                case /* uint64 creator */ 4:
                    message.creator = reader.uint64().toBigInt();
                    break;
                case /* optional string motd */ 5:
                    message.motd = reader.string();
                    break;
                case /* optional int64 motdTimestamp */ 6:
                    message.motdTimestamp = reader.int64().toBigInt();
                    break;
                case /* optional uint64 motdAuthor */ 7:
                    message.motdAuthor = reader.uint64().toBigInt();
                    break;
                case /* optional bytes logo */ 8:
                    message.logo = reader.bytes();
                    break;
                case /* optional sint32 color */ 9:
                    message.color = reader.sint32();
                    break;
                case /* repeated rustplus.ClanInfo.Role roles */ 10:
                    message.roles.push(ClanInfo_Role.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated rustplus.ClanInfo.Member members */ 11:
                    message.members.push(ClanInfo_Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated rustplus.ClanInfo.Invite invites */ 12:
                    message.invites.push(ClanInfo_Invite.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 maxMemberCount */ 13:
                    message.maxMemberCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 clanId = 1; */
        if (message.clanId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.clanId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 created = 3; */
        if (message.created !== 0n)
            writer.tag(3, WireType.Varint).int64(message.created);
        /* uint64 creator = 4; */
        if (message.creator !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.creator);
        /* optional string motd = 5; */
        if (message.motd !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.motd);
        /* optional int64 motdTimestamp = 6; */
        if (message.motdTimestamp !== undefined)
            writer.tag(6, WireType.Varint).int64(message.motdTimestamp);
        /* optional uint64 motdAuthor = 7; */
        if (message.motdAuthor !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.motdAuthor);
        /* optional bytes logo = 8; */
        if (message.logo !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.logo);
        /* optional sint32 color = 9; */
        if (message.color !== undefined)
            writer.tag(9, WireType.Varint).sint32(message.color);
        /* repeated rustplus.ClanInfo.Role roles = 10; */
        for (let i = 0; i < message.roles.length; i++)
            ClanInfo_Role.internalBinaryWrite(message.roles[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated rustplus.ClanInfo.Member members = 11; */
        for (let i = 0; i < message.members.length; i++)
            ClanInfo_Member.internalBinaryWrite(message.members[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated rustplus.ClanInfo.Invite invites = 12; */
        for (let i = 0; i < message.invites.length; i++)
            ClanInfo_Invite.internalBinaryWrite(message.invites[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 maxMemberCount = 13; */
        if (message.maxMemberCount !== undefined)
            writer.tag(13, WireType.Varint).int32(message.maxMemberCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanInfo
 */
export const ClanInfo = new ClanInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanInfo_Role$Type extends MessageType<ClanInfo_Role> {
    constructor() {
        super("rustplus.ClanInfo.Role", [
            { no: 1, name: "roleId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "canSetMotd", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "canSetLogo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "canInvite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "canKick", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "canPromote", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "canDemote", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "canSetPlayerNotes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "canAccessLogs", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ClanInfo_Role>): ClanInfo_Role {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleId = 0;
        message.rank = 0;
        message.name = "";
        message.canSetMotd = false;
        message.canSetLogo = false;
        message.canInvite = false;
        message.canKick = false;
        message.canPromote = false;
        message.canDemote = false;
        message.canSetPlayerNotes = false;
        message.canAccessLogs = false;
        if (value !== undefined)
            reflectionMergePartial<ClanInfo_Role>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanInfo_Role): ClanInfo_Role {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 roleId */ 1:
                    message.roleId = reader.int32();
                    break;
                case /* int32 rank */ 2:
                    message.rank = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* bool canSetMotd */ 4:
                    message.canSetMotd = reader.bool();
                    break;
                case /* bool canSetLogo */ 5:
                    message.canSetLogo = reader.bool();
                    break;
                case /* bool canInvite */ 6:
                    message.canInvite = reader.bool();
                    break;
                case /* bool canKick */ 7:
                    message.canKick = reader.bool();
                    break;
                case /* bool canPromote */ 8:
                    message.canPromote = reader.bool();
                    break;
                case /* bool canDemote */ 9:
                    message.canDemote = reader.bool();
                    break;
                case /* bool canSetPlayerNotes */ 10:
                    message.canSetPlayerNotes = reader.bool();
                    break;
                case /* bool canAccessLogs */ 11:
                    message.canAccessLogs = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanInfo_Role, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 roleId = 1; */
        if (message.roleId !== 0)
            writer.tag(1, WireType.Varint).int32(message.roleId);
        /* int32 rank = 2; */
        if (message.rank !== 0)
            writer.tag(2, WireType.Varint).int32(message.rank);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* bool canSetMotd = 4; */
        if (message.canSetMotd !== false)
            writer.tag(4, WireType.Varint).bool(message.canSetMotd);
        /* bool canSetLogo = 5; */
        if (message.canSetLogo !== false)
            writer.tag(5, WireType.Varint).bool(message.canSetLogo);
        /* bool canInvite = 6; */
        if (message.canInvite !== false)
            writer.tag(6, WireType.Varint).bool(message.canInvite);
        /* bool canKick = 7; */
        if (message.canKick !== false)
            writer.tag(7, WireType.Varint).bool(message.canKick);
        /* bool canPromote = 8; */
        if (message.canPromote !== false)
            writer.tag(8, WireType.Varint).bool(message.canPromote);
        /* bool canDemote = 9; */
        if (message.canDemote !== false)
            writer.tag(9, WireType.Varint).bool(message.canDemote);
        /* bool canSetPlayerNotes = 10; */
        if (message.canSetPlayerNotes !== false)
            writer.tag(10, WireType.Varint).bool(message.canSetPlayerNotes);
        /* bool canAccessLogs = 11; */
        if (message.canAccessLogs !== false)
            writer.tag(11, WireType.Varint).bool(message.canAccessLogs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanInfo.Role
 */
export const ClanInfo_Role = new ClanInfo_Role$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanInfo_Member$Type extends MessageType<ClanInfo_Member> {
    constructor() {
        super("rustplus.ClanInfo.Member", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "roleId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "joined", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "lastSeen", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "online", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ClanInfo_Member>): ClanInfo_Member {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamId = 0n;
        message.roleId = 0;
        message.joined = 0n;
        message.lastSeen = 0n;
        if (value !== undefined)
            reflectionMergePartial<ClanInfo_Member>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanInfo_Member): ClanInfo_Member {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                case /* int32 roleId */ 2:
                    message.roleId = reader.int32();
                    break;
                case /* int64 joined */ 3:
                    message.joined = reader.int64().toBigInt();
                    break;
                case /* int64 lastSeen */ 4:
                    message.lastSeen = reader.int64().toBigInt();
                    break;
                case /* optional string notes */ 5:
                    message.notes = reader.string();
                    break;
                case /* optional bool online */ 6:
                    message.online = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanInfo_Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1; */
        if (message.steamId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* int32 roleId = 2; */
        if (message.roleId !== 0)
            writer.tag(2, WireType.Varint).int32(message.roleId);
        /* int64 joined = 3; */
        if (message.joined !== 0n)
            writer.tag(3, WireType.Varint).int64(message.joined);
        /* int64 lastSeen = 4; */
        if (message.lastSeen !== 0n)
            writer.tag(4, WireType.Varint).int64(message.lastSeen);
        /* optional string notes = 5; */
        if (message.notes !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.notes);
        /* optional bool online = 6; */
        if (message.online !== undefined)
            writer.tag(6, WireType.Varint).bool(message.online);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanInfo.Member
 */
export const ClanInfo_Member = new ClanInfo_Member$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanInfo_Invite$Type extends MessageType<ClanInfo_Invite> {
    constructor() {
        super("rustplus.ClanInfo.Invite", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "recruiter", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ClanInfo_Invite>): ClanInfo_Invite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamId = 0n;
        message.recruiter = 0n;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<ClanInfo_Invite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanInfo_Invite): ClanInfo_Invite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                case /* uint64 recruiter */ 2:
                    message.recruiter = reader.uint64().toBigInt();
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanInfo_Invite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1; */
        if (message.steamId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* uint64 recruiter = 2; */
        if (message.recruiter !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.recruiter);
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanInfo.Invite
 */
export const ClanInfo_Invite = new ClanInfo_Invite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanLog$Type extends MessageType<ClanLog> {
    constructor() {
        super("rustplus.ClanLog", [
            { no: 1, name: "clanId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "logEntries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClanLog_Entry }
        ]);
    }
    create(value?: PartialMessage<ClanLog>): ClanLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clanId = 0n;
        message.logEntries = [];
        if (value !== undefined)
            reflectionMergePartial<ClanLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanLog): ClanLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 clanId */ 1:
                    message.clanId = reader.int64().toBigInt();
                    break;
                case /* repeated rustplus.ClanLog.Entry logEntries */ 2:
                    message.logEntries.push(ClanLog_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 clanId = 1; */
        if (message.clanId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.clanId);
        /* repeated rustplus.ClanLog.Entry logEntries = 2; */
        for (let i = 0; i < message.logEntries.length; i++)
            ClanLog_Entry.internalBinaryWrite(message.logEntries[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanLog
 */
export const ClanLog = new ClanLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanLog_Entry$Type extends MessageType<ClanLog_Entry> {
    constructor() {
        super("rustplus.ClanLog.Entry", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eventKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "arg1", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "arg2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "arg3", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "arg4", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClanLog_Entry>): ClanLog_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        message.eventKey = "";
        if (value !== undefined)
            reflectionMergePartial<ClanLog_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanLog_Entry): ClanLog_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* string eventKey */ 2:
                    message.eventKey = reader.string();
                    break;
                case /* optional string arg1 */ 3:
                    message.arg1 = reader.string();
                    break;
                case /* optional string arg2 */ 4:
                    message.arg2 = reader.string();
                    break;
                case /* optional string arg3 */ 5:
                    message.arg3 = reader.string();
                    break;
                case /* optional string arg4 */ 6:
                    message.arg4 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanLog_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* string eventKey = 2; */
        if (message.eventKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.eventKey);
        /* optional string arg1 = 3; */
        if (message.arg1 !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.arg1);
        /* optional string arg2 = 4; */
        if (message.arg2 !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.arg2);
        /* optional string arg3 = 5; */
        if (message.arg3 !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.arg3);
        /* optional string arg4 = 6; */
        if (message.arg4 !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.arg4);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanLog.Entry
 */
export const ClanLog_Entry = new ClanLog_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanInvitations$Type extends MessageType<ClanInvitations> {
    constructor() {
        super("rustplus.ClanInvitations", [
            { no: 1, name: "invitations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClanInvitations_Invitation }
        ]);
    }
    create(value?: PartialMessage<ClanInvitations>): ClanInvitations {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.invitations = [];
        if (value !== undefined)
            reflectionMergePartial<ClanInvitations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanInvitations): ClanInvitations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rustplus.ClanInvitations.Invitation invitations */ 1:
                    message.invitations.push(ClanInvitations_Invitation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanInvitations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rustplus.ClanInvitations.Invitation invitations = 1; */
        for (let i = 0; i < message.invitations.length; i++)
            ClanInvitations_Invitation.internalBinaryWrite(message.invitations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanInvitations
 */
export const ClanInvitations = new ClanInvitations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClanInvitations_Invitation$Type extends MessageType<ClanInvitations_Invitation> {
    constructor() {
        super("rustplus.ClanInvitations.Invitation", [
            { no: 1, name: "clanId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "recruiter", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ClanInvitations_Invitation>): ClanInvitations_Invitation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clanId = 0n;
        message.recruiter = 0n;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<ClanInvitations_Invitation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClanInvitations_Invitation): ClanInvitations_Invitation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 clanId */ 1:
                    message.clanId = reader.int64().toBigInt();
                    break;
                case /* uint64 recruiter */ 2:
                    message.recruiter = reader.uint64().toBigInt();
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClanInvitations_Invitation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 clanId = 1; */
        if (message.clanId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.clanId);
        /* uint64 recruiter = 2; */
        if (message.recruiter !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.recruiter);
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.ClanInvitations.Invitation
 */
export const ClanInvitations_Invitation = new ClanInvitations_Invitation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppRequest$Type extends MessageType<AppRequest> {
    constructor() {
        super("rustplus.AppRequest", [
            { no: 1, name: "seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "playerId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "playerToken", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "entityId", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "getInfo", kind: "message", T: () => AppEmpty },
            { no: 9, name: "getTime", kind: "message", T: () => AppEmpty },
            { no: 10, name: "getMap", kind: "message", T: () => AppEmpty },
            { no: 11, name: "getTeamInfo", kind: "message", T: () => AppEmpty },
            { no: 12, name: "getTeamChat", kind: "message", T: () => AppEmpty },
            { no: 13, name: "sendTeamMessage", kind: "message", T: () => AppSendMessage },
            { no: 14, name: "getEntityInfo", kind: "message", T: () => AppEmpty },
            { no: 15, name: "setEntityValue", kind: "message", T: () => AppSetEntityValue },
            { no: 16, name: "checkSubscription", kind: "message", T: () => AppEmpty },
            { no: 17, name: "setSubscription", kind: "message", T: () => AppFlag },
            { no: 18, name: "getMapMarkers", kind: "message", T: () => AppEmpty },
            { no: 20, name: "promoteToLeader", kind: "message", T: () => AppPromoteToLeader },
            { no: 21, name: "getClanInfo", kind: "message", T: () => AppEmpty },
            { no: 22, name: "setClanMotd", kind: "message", T: () => AppSendMessage },
            { no: 23, name: "getClanChat", kind: "message", T: () => AppEmpty },
            { no: 24, name: "sendClanMessage", kind: "message", T: () => AppSendMessage },
            { no: 25, name: "getNexusAuth", kind: "message", T: () => AppGetNexusAuth },
            { no: 30, name: "cameraSubscribe", kind: "message", T: () => AppCameraSubscribe },
            { no: 31, name: "cameraUnsubscribe", kind: "message", T: () => AppEmpty },
            { no: 32, name: "cameraInput", kind: "message", T: () => AppCameraInput }
        ]);
    }
    create(value?: PartialMessage<AppRequest>): AppRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seq = 0;
        message.playerId = 0n;
        message.playerToken = 0;
        if (value !== undefined)
            reflectionMergePartial<AppRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppRequest): AppRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 seq */ 1:
                    message.seq = reader.uint32();
                    break;
                case /* uint64 playerId */ 2:
                    message.playerId = reader.uint64().toBigInt();
                    break;
                case /* int32 playerToken */ 3:
                    message.playerToken = reader.int32();
                    break;
                case /* optional uint32 entityId */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* optional rustplus.AppEmpty getInfo */ 8:
                    message.getInfo = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getInfo);
                    break;
                case /* optional rustplus.AppEmpty getTime */ 9:
                    message.getTime = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getTime);
                    break;
                case /* optional rustplus.AppEmpty getMap */ 10:
                    message.getMap = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getMap);
                    break;
                case /* optional rustplus.AppEmpty getTeamInfo */ 11:
                    message.getTeamInfo = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getTeamInfo);
                    break;
                case /* optional rustplus.AppEmpty getTeamChat */ 12:
                    message.getTeamChat = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getTeamChat);
                    break;
                case /* optional rustplus.AppSendMessage sendTeamMessage */ 13:
                    message.sendTeamMessage = AppSendMessage.internalBinaryRead(reader, reader.uint32(), options, message.sendTeamMessage);
                    break;
                case /* optional rustplus.AppEmpty getEntityInfo */ 14:
                    message.getEntityInfo = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getEntityInfo);
                    break;
                case /* optional rustplus.AppSetEntityValue setEntityValue */ 15:
                    message.setEntityValue = AppSetEntityValue.internalBinaryRead(reader, reader.uint32(), options, message.setEntityValue);
                    break;
                case /* optional rustplus.AppEmpty checkSubscription */ 16:
                    message.checkSubscription = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.checkSubscription);
                    break;
                case /* optional rustplus.AppFlag setSubscription */ 17:
                    message.setSubscription = AppFlag.internalBinaryRead(reader, reader.uint32(), options, message.setSubscription);
                    break;
                case /* optional rustplus.AppEmpty getMapMarkers */ 18:
                    message.getMapMarkers = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getMapMarkers);
                    break;
                case /* optional rustplus.AppPromoteToLeader promoteToLeader */ 20:
                    message.promoteToLeader = AppPromoteToLeader.internalBinaryRead(reader, reader.uint32(), options, message.promoteToLeader);
                    break;
                case /* optional rustplus.AppEmpty getClanInfo */ 21:
                    message.getClanInfo = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getClanInfo);
                    break;
                case /* optional rustplus.AppSendMessage setClanMotd */ 22:
                    message.setClanMotd = AppSendMessage.internalBinaryRead(reader, reader.uint32(), options, message.setClanMotd);
                    break;
                case /* optional rustplus.AppEmpty getClanChat */ 23:
                    message.getClanChat = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.getClanChat);
                    break;
                case /* optional rustplus.AppSendMessage sendClanMessage */ 24:
                    message.sendClanMessage = AppSendMessage.internalBinaryRead(reader, reader.uint32(), options, message.sendClanMessage);
                    break;
                case /* optional rustplus.AppGetNexusAuth getNexusAuth */ 25:
                    message.getNexusAuth = AppGetNexusAuth.internalBinaryRead(reader, reader.uint32(), options, message.getNexusAuth);
                    break;
                case /* optional rustplus.AppCameraSubscribe cameraSubscribe */ 30:
                    message.cameraSubscribe = AppCameraSubscribe.internalBinaryRead(reader, reader.uint32(), options, message.cameraSubscribe);
                    break;
                case /* optional rustplus.AppEmpty cameraUnsubscribe */ 31:
                    message.cameraUnsubscribe = AppEmpty.internalBinaryRead(reader, reader.uint32(), options, message.cameraUnsubscribe);
                    break;
                case /* optional rustplus.AppCameraInput cameraInput */ 32:
                    message.cameraInput = AppCameraInput.internalBinaryRead(reader, reader.uint32(), options, message.cameraInput);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 seq = 1; */
        if (message.seq !== 0)
            writer.tag(1, WireType.Varint).uint32(message.seq);
        /* uint64 playerId = 2; */
        if (message.playerId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.playerId);
        /* int32 playerToken = 3; */
        if (message.playerToken !== 0)
            writer.tag(3, WireType.Varint).int32(message.playerToken);
        /* optional uint32 entityId = 4; */
        if (message.entityId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* optional rustplus.AppEmpty getInfo = 8; */
        if (message.getInfo)
            AppEmpty.internalBinaryWrite(message.getInfo, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getTime = 9; */
        if (message.getTime)
            AppEmpty.internalBinaryWrite(message.getTime, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getMap = 10; */
        if (message.getMap)
            AppEmpty.internalBinaryWrite(message.getMap, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getTeamInfo = 11; */
        if (message.getTeamInfo)
            AppEmpty.internalBinaryWrite(message.getTeamInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getTeamChat = 12; */
        if (message.getTeamChat)
            AppEmpty.internalBinaryWrite(message.getTeamChat, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppSendMessage sendTeamMessage = 13; */
        if (message.sendTeamMessage)
            AppSendMessage.internalBinaryWrite(message.sendTeamMessage, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getEntityInfo = 14; */
        if (message.getEntityInfo)
            AppEmpty.internalBinaryWrite(message.getEntityInfo, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppSetEntityValue setEntityValue = 15; */
        if (message.setEntityValue)
            AppSetEntityValue.internalBinaryWrite(message.setEntityValue, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty checkSubscription = 16; */
        if (message.checkSubscription)
            AppEmpty.internalBinaryWrite(message.checkSubscription, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppFlag setSubscription = 17; */
        if (message.setSubscription)
            AppFlag.internalBinaryWrite(message.setSubscription, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getMapMarkers = 18; */
        if (message.getMapMarkers)
            AppEmpty.internalBinaryWrite(message.getMapMarkers, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppPromoteToLeader promoteToLeader = 20; */
        if (message.promoteToLeader)
            AppPromoteToLeader.internalBinaryWrite(message.promoteToLeader, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getClanInfo = 21; */
        if (message.getClanInfo)
            AppEmpty.internalBinaryWrite(message.getClanInfo, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppSendMessage setClanMotd = 22; */
        if (message.setClanMotd)
            AppSendMessage.internalBinaryWrite(message.setClanMotd, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty getClanChat = 23; */
        if (message.getClanChat)
            AppEmpty.internalBinaryWrite(message.getClanChat, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppSendMessage sendClanMessage = 24; */
        if (message.sendClanMessage)
            AppSendMessage.internalBinaryWrite(message.sendClanMessage, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppGetNexusAuth getNexusAuth = 25; */
        if (message.getNexusAuth)
            AppGetNexusAuth.internalBinaryWrite(message.getNexusAuth, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppCameraSubscribe cameraSubscribe = 30; */
        if (message.cameraSubscribe)
            AppCameraSubscribe.internalBinaryWrite(message.cameraSubscribe, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEmpty cameraUnsubscribe = 31; */
        if (message.cameraUnsubscribe)
            AppEmpty.internalBinaryWrite(message.cameraUnsubscribe, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppCameraInput cameraInput = 32; */
        if (message.cameraInput)
            AppCameraInput.internalBinaryWrite(message.cameraInput, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppRequest
 */
export const AppRequest = new AppRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMessage$Type extends MessageType<AppMessage> {
    constructor() {
        super("rustplus.AppMessage", [
            { no: 1, name: "response", kind: "message", T: () => AppResponse },
            { no: 2, name: "broadcast", kind: "message", T: () => AppBroadcast }
        ]);
    }
    create(value?: PartialMessage<AppMessage>): AppMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMessage): AppMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional rustplus.AppResponse response */ 1:
                    message.response = AppResponse.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                case /* optional rustplus.AppBroadcast broadcast */ 2:
                    message.broadcast = AppBroadcast.internalBinaryRead(reader, reader.uint32(), options, message.broadcast);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional rustplus.AppResponse response = 1; */
        if (message.response)
            AppResponse.internalBinaryWrite(message.response, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppBroadcast broadcast = 2; */
        if (message.broadcast)
            AppBroadcast.internalBinaryWrite(message.broadcast, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMessage
 */
export const AppMessage = new AppMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppResponse$Type extends MessageType<AppResponse> {
    constructor() {
        super("rustplus.AppResponse", [
            { no: 1, name: "seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "success", kind: "message", T: () => AppSuccess },
            { no: 5, name: "error", kind: "message", T: () => AppError },
            { no: 6, name: "info", kind: "message", T: () => AppInfo },
            { no: 7, name: "time", kind: "message", T: () => AppTime },
            { no: 8, name: "map", kind: "message", T: () => AppMap },
            { no: 9, name: "teamInfo", kind: "message", T: () => AppTeamInfo },
            { no: 10, name: "teamChat", kind: "message", T: () => AppTeamChat },
            { no: 11, name: "entityInfo", kind: "message", T: () => AppEntityInfo },
            { no: 12, name: "flag", kind: "message", T: () => AppFlag },
            { no: 13, name: "mapMarkers", kind: "message", T: () => AppMapMarkers },
            { no: 15, name: "clanInfo", kind: "message", T: () => AppClanInfo },
            { no: 16, name: "clanChat", kind: "message", T: () => AppClanChat },
            { no: 17, name: "nexusAuth", kind: "message", T: () => AppNexusAuth },
            { no: 20, name: "cameraSubscribeInfo", kind: "message", T: () => AppCameraInfo }
        ]);
    }
    create(value?: PartialMessage<AppResponse>): AppResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seq = 0;
        if (value !== undefined)
            reflectionMergePartial<AppResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppResponse): AppResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 seq */ 1:
                    message.seq = reader.uint32();
                    break;
                case /* optional rustplus.AppSuccess success */ 4:
                    message.success = AppSuccess.internalBinaryRead(reader, reader.uint32(), options, message.success);
                    break;
                case /* optional rustplus.AppError error */ 5:
                    message.error = AppError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* optional rustplus.AppInfo info */ 6:
                    message.info = AppInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* optional rustplus.AppTime time */ 7:
                    message.time = AppTime.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* optional rustplus.AppMap map */ 8:
                    message.map = AppMap.internalBinaryRead(reader, reader.uint32(), options, message.map);
                    break;
                case /* optional rustplus.AppTeamInfo teamInfo */ 9:
                    message.teamInfo = AppTeamInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamInfo);
                    break;
                case /* optional rustplus.AppTeamChat teamChat */ 10:
                    message.teamChat = AppTeamChat.internalBinaryRead(reader, reader.uint32(), options, message.teamChat);
                    break;
                case /* optional rustplus.AppEntityInfo entityInfo */ 11:
                    message.entityInfo = AppEntityInfo.internalBinaryRead(reader, reader.uint32(), options, message.entityInfo);
                    break;
                case /* optional rustplus.AppFlag flag */ 12:
                    message.flag = AppFlag.internalBinaryRead(reader, reader.uint32(), options, message.flag);
                    break;
                case /* optional rustplus.AppMapMarkers mapMarkers */ 13:
                    message.mapMarkers = AppMapMarkers.internalBinaryRead(reader, reader.uint32(), options, message.mapMarkers);
                    break;
                case /* optional rustplus.AppClanInfo clanInfo */ 15:
                    message.clanInfo = AppClanInfo.internalBinaryRead(reader, reader.uint32(), options, message.clanInfo);
                    break;
                case /* optional rustplus.AppClanChat clanChat */ 16:
                    message.clanChat = AppClanChat.internalBinaryRead(reader, reader.uint32(), options, message.clanChat);
                    break;
                case /* optional rustplus.AppNexusAuth nexusAuth */ 17:
                    message.nexusAuth = AppNexusAuth.internalBinaryRead(reader, reader.uint32(), options, message.nexusAuth);
                    break;
                case /* optional rustplus.AppCameraInfo cameraSubscribeInfo */ 20:
                    message.cameraSubscribeInfo = AppCameraInfo.internalBinaryRead(reader, reader.uint32(), options, message.cameraSubscribeInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 seq = 1; */
        if (message.seq !== 0)
            writer.tag(1, WireType.Varint).uint32(message.seq);
        /* optional rustplus.AppSuccess success = 4; */
        if (message.success)
            AppSuccess.internalBinaryWrite(message.success, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppError error = 5; */
        if (message.error)
            AppError.internalBinaryWrite(message.error, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppInfo info = 6; */
        if (message.info)
            AppInfo.internalBinaryWrite(message.info, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppTime time = 7; */
        if (message.time)
            AppTime.internalBinaryWrite(message.time, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppMap map = 8; */
        if (message.map)
            AppMap.internalBinaryWrite(message.map, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppTeamInfo teamInfo = 9; */
        if (message.teamInfo)
            AppTeamInfo.internalBinaryWrite(message.teamInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppTeamChat teamChat = 10; */
        if (message.teamChat)
            AppTeamChat.internalBinaryWrite(message.teamChat, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEntityInfo entityInfo = 11; */
        if (message.entityInfo)
            AppEntityInfo.internalBinaryWrite(message.entityInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppFlag flag = 12; */
        if (message.flag)
            AppFlag.internalBinaryWrite(message.flag, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppMapMarkers mapMarkers = 13; */
        if (message.mapMarkers)
            AppMapMarkers.internalBinaryWrite(message.mapMarkers, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppClanInfo clanInfo = 15; */
        if (message.clanInfo)
            AppClanInfo.internalBinaryWrite(message.clanInfo, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppClanChat clanChat = 16; */
        if (message.clanChat)
            AppClanChat.internalBinaryWrite(message.clanChat, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppNexusAuth nexusAuth = 17; */
        if (message.nexusAuth)
            AppNexusAuth.internalBinaryWrite(message.nexusAuth, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppCameraInfo cameraSubscribeInfo = 20; */
        if (message.cameraSubscribeInfo)
            AppCameraInfo.internalBinaryWrite(message.cameraSubscribeInfo, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppResponse
 */
export const AppResponse = new AppResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppBroadcast$Type extends MessageType<AppBroadcast> {
    constructor() {
        super("rustplus.AppBroadcast", [
            { no: 4, name: "teamChanged", kind: "message", T: () => AppTeamChanged },
            { no: 5, name: "teamMessage", kind: "message", T: () => AppNewTeamMessage },
            { no: 6, name: "entityChanged", kind: "message", T: () => AppEntityChanged },
            { no: 7, name: "clanChanged", kind: "message", T: () => AppClanChanged },
            { no: 8, name: "clanMessage", kind: "message", T: () => AppNewClanMessage },
            { no: 10, name: "cameraRays", kind: "message", T: () => AppCameraRays }
        ]);
    }
    create(value?: PartialMessage<AppBroadcast>): AppBroadcast {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppBroadcast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppBroadcast): AppBroadcast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional rustplus.AppTeamChanged teamChanged */ 4:
                    message.teamChanged = AppTeamChanged.internalBinaryRead(reader, reader.uint32(), options, message.teamChanged);
                    break;
                case /* optional rustplus.AppNewTeamMessage teamMessage */ 5:
                    message.teamMessage = AppNewTeamMessage.internalBinaryRead(reader, reader.uint32(), options, message.teamMessage);
                    break;
                case /* optional rustplus.AppEntityChanged entityChanged */ 6:
                    message.entityChanged = AppEntityChanged.internalBinaryRead(reader, reader.uint32(), options, message.entityChanged);
                    break;
                case /* optional rustplus.AppClanChanged clanChanged */ 7:
                    message.clanChanged = AppClanChanged.internalBinaryRead(reader, reader.uint32(), options, message.clanChanged);
                    break;
                case /* optional rustplus.AppNewClanMessage clanMessage */ 8:
                    message.clanMessage = AppNewClanMessage.internalBinaryRead(reader, reader.uint32(), options, message.clanMessage);
                    break;
                case /* optional rustplus.AppCameraRays cameraRays */ 10:
                    message.cameraRays = AppCameraRays.internalBinaryRead(reader, reader.uint32(), options, message.cameraRays);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppBroadcast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional rustplus.AppTeamChanged teamChanged = 4; */
        if (message.teamChanged)
            AppTeamChanged.internalBinaryWrite(message.teamChanged, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppNewTeamMessage teamMessage = 5; */
        if (message.teamMessage)
            AppNewTeamMessage.internalBinaryWrite(message.teamMessage, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppEntityChanged entityChanged = 6; */
        if (message.entityChanged)
            AppEntityChanged.internalBinaryWrite(message.entityChanged, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppClanChanged clanChanged = 7; */
        if (message.clanChanged)
            AppClanChanged.internalBinaryWrite(message.clanChanged, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppNewClanMessage clanMessage = 8; */
        if (message.clanMessage)
            AppNewClanMessage.internalBinaryWrite(message.clanMessage, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.AppCameraRays cameraRays = 10; */
        if (message.cameraRays)
            AppCameraRays.internalBinaryWrite(message.cameraRays, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppBroadcast
 */
export const AppBroadcast = new AppBroadcast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEmpty$Type extends MessageType<AppEmpty> {
    constructor() {
        super("rustplus.AppEmpty", []);
    }
    create(value?: PartialMessage<AppEmpty>): AppEmpty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppEmpty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEmpty): AppEmpty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AppEmpty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEmpty
 */
export const AppEmpty = new AppEmpty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSendMessage$Type extends MessageType<AppSendMessage> {
    constructor() {
        super("rustplus.AppSendMessage", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppSendMessage>): AppSendMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<AppSendMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSendMessage): AppSendMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSendMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppSendMessage
 */
export const AppSendMessage = new AppSendMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSetEntityValue$Type extends MessageType<AppSetEntityValue> {
    constructor() {
        super("rustplus.AppSetEntityValue", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppSetEntityValue>): AppSetEntityValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<AppSetEntityValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSetEntityValue): AppSetEntityValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppSetEntityValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppSetEntityValue
 */
export const AppSetEntityValue = new AppSetEntityValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppPromoteToLeader$Type extends MessageType<AppPromoteToLeader> {
    constructor() {
        super("rustplus.AppPromoteToLeader", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AppPromoteToLeader>): AppPromoteToLeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamId = 0n;
        if (value !== undefined)
            reflectionMergePartial<AppPromoteToLeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppPromoteToLeader): AppPromoteToLeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppPromoteToLeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1; */
        if (message.steamId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppPromoteToLeader
 */
export const AppPromoteToLeader = new AppPromoteToLeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppGetNexusAuth$Type extends MessageType<AppGetNexusAuth> {
    constructor() {
        super("rustplus.AppGetNexusAuth", [
            { no: 1, name: "appKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppGetNexusAuth>): AppGetNexusAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appKey = "";
        if (value !== undefined)
            reflectionMergePartial<AppGetNexusAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppGetNexusAuth): AppGetNexusAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string appKey */ 1:
                    message.appKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppGetNexusAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string appKey = 1; */
        if (message.appKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppGetNexusAuth
 */
export const AppGetNexusAuth = new AppGetNexusAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppSuccess$Type extends MessageType<AppSuccess> {
    constructor() {
        super("rustplus.AppSuccess", []);
    }
    create(value?: PartialMessage<AppSuccess>): AppSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppSuccess): AppSuccess {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AppSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppSuccess
 */
export const AppSuccess = new AppSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppError$Type extends MessageType<AppError> {
    constructor() {
        super("rustplus.AppError", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppError>): AppError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<AppError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppError): AppError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppError
 */
export const AppError = new AppError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppFlag$Type extends MessageType<AppFlag> {
    constructor() {
        super("rustplus.AppFlag", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppFlag>): AppFlag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<AppFlag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppFlag): AppFlag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppFlag
 */
export const AppFlag = new AppFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppInfo$Type extends MessageType<AppInfo> {
    constructor() {
        super("rustplus.AppInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "headerImage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "map", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "mapSize", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "wipeTime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "players", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "maxPlayers", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "queuedPlayers", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "seed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "salt", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "logoImage", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "nexus", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "nexusId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "nexusZone", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppInfo>): AppInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.headerImage = "";
        message.url = "";
        message.map = "";
        message.mapSize = 0;
        message.wipeTime = 0;
        message.players = 0;
        message.maxPlayers = 0;
        message.queuedPlayers = 0;
        if (value !== undefined)
            reflectionMergePartial<AppInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppInfo): AppInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string headerImage */ 2:
                    message.headerImage = reader.string();
                    break;
                case /* string url */ 3:
                    message.url = reader.string();
                    break;
                case /* string map */ 4:
                    message.map = reader.string();
                    break;
                case /* uint32 mapSize */ 5:
                    message.mapSize = reader.uint32();
                    break;
                case /* uint32 wipeTime */ 6:
                    message.wipeTime = reader.uint32();
                    break;
                case /* uint32 players */ 7:
                    message.players = reader.uint32();
                    break;
                case /* uint32 maxPlayers */ 8:
                    message.maxPlayers = reader.uint32();
                    break;
                case /* uint32 queuedPlayers */ 9:
                    message.queuedPlayers = reader.uint32();
                    break;
                case /* optional uint32 seed */ 10:
                    message.seed = reader.uint32();
                    break;
                case /* optional uint32 salt */ 11:
                    message.salt = reader.uint32();
                    break;
                case /* optional string logoImage */ 12:
                    message.logoImage = reader.string();
                    break;
                case /* optional string nexus */ 13:
                    message.nexus = reader.string();
                    break;
                case /* optional int32 nexusId */ 14:
                    message.nexusId = reader.int32();
                    break;
                case /* optional string nexusZone */ 15:
                    message.nexusZone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string headerImage = 2; */
        if (message.headerImage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.headerImage);
        /* string url = 3; */
        if (message.url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* string map = 4; */
        if (message.map !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.map);
        /* uint32 mapSize = 5; */
        if (message.mapSize !== 0)
            writer.tag(5, WireType.Varint).uint32(message.mapSize);
        /* uint32 wipeTime = 6; */
        if (message.wipeTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.wipeTime);
        /* uint32 players = 7; */
        if (message.players !== 0)
            writer.tag(7, WireType.Varint).uint32(message.players);
        /* uint32 maxPlayers = 8; */
        if (message.maxPlayers !== 0)
            writer.tag(8, WireType.Varint).uint32(message.maxPlayers);
        /* uint32 queuedPlayers = 9; */
        if (message.queuedPlayers !== 0)
            writer.tag(9, WireType.Varint).uint32(message.queuedPlayers);
        /* optional uint32 seed = 10; */
        if (message.seed !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.seed);
        /* optional uint32 salt = 11; */
        if (message.salt !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.salt);
        /* optional string logoImage = 12; */
        if (message.logoImage !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.logoImage);
        /* optional string nexus = 13; */
        if (message.nexus !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.nexus);
        /* optional int32 nexusId = 14; */
        if (message.nexusId !== undefined)
            writer.tag(14, WireType.Varint).int32(message.nexusId);
        /* optional string nexusZone = 15; */
        if (message.nexusZone !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.nexusZone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppInfo
 */
export const AppInfo = new AppInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTime$Type extends MessageType<AppTime> {
    constructor() {
        super("rustplus.AppTime", [
            { no: 1, name: "dayLengthMinutes", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "timeScale", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "sunrise", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "sunset", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "time", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AppTime>): AppTime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dayLengthMinutes = 0;
        message.timeScale = 0;
        message.sunrise = 0;
        message.sunset = 0;
        message.time = 0;
        if (value !== undefined)
            reflectionMergePartial<AppTime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTime): AppTime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float dayLengthMinutes */ 1:
                    message.dayLengthMinutes = reader.float();
                    break;
                case /* float timeScale */ 2:
                    message.timeScale = reader.float();
                    break;
                case /* float sunrise */ 3:
                    message.sunrise = reader.float();
                    break;
                case /* float sunset */ 4:
                    message.sunset = reader.float();
                    break;
                case /* float time */ 5:
                    message.time = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float dayLengthMinutes = 1; */
        if (message.dayLengthMinutes !== 0)
            writer.tag(1, WireType.Bit32).float(message.dayLengthMinutes);
        /* float timeScale = 2; */
        if (message.timeScale !== 0)
            writer.tag(2, WireType.Bit32).float(message.timeScale);
        /* float sunrise = 3; */
        if (message.sunrise !== 0)
            writer.tag(3, WireType.Bit32).float(message.sunrise);
        /* float sunset = 4; */
        if (message.sunset !== 0)
            writer.tag(4, WireType.Bit32).float(message.sunset);
        /* float time = 5; */
        if (message.time !== 0)
            writer.tag(5, WireType.Bit32).float(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTime
 */
export const AppTime = new AppTime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMap$Type extends MessageType<AppMap> {
    constructor() {
        super("rustplus.AppMap", [
            { no: 1, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "jpgImage", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "oceanMargin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "monuments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppMap_Monument },
            { no: 6, name: "background", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppMap>): AppMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        message.jpgImage = new Uint8Array(0);
        message.oceanMargin = 0;
        message.monuments = [];
        if (value !== undefined)
            reflectionMergePartial<AppMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMap): AppMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 width */ 1:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                case /* bytes jpgImage */ 3:
                    message.jpgImage = reader.bytes();
                    break;
                case /* int32 oceanMargin */ 4:
                    message.oceanMargin = reader.int32();
                    break;
                case /* repeated rustplus.AppMap.Monument monuments */ 5:
                    message.monuments.push(AppMap_Monument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string background */ 6:
                    message.background = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* uint32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        /* bytes jpgImage = 3; */
        if (message.jpgImage.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.jpgImage);
        /* int32 oceanMargin = 4; */
        if (message.oceanMargin !== 0)
            writer.tag(4, WireType.Varint).int32(message.oceanMargin);
        /* repeated rustplus.AppMap.Monument monuments = 5; */
        for (let i = 0; i < message.monuments.length; i++)
            AppMap_Monument.internalBinaryWrite(message.monuments[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string background = 6; */
        if (message.background !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.background);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMap
 */
export const AppMap = new AppMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMap_Monument$Type extends MessageType<AppMap_Monument> {
    constructor() {
        super("rustplus.AppMap.Monument", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AppMap_Monument>): AppMap_Monument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<AppMap_Monument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMap_Monument): AppMap_Monument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMap_Monument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMap.Monument
 */
export const AppMap_Monument = new AppMap_Monument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityInfo$Type extends MessageType<AppEntityInfo> {
    constructor() {
        super("rustplus.AppEntityInfo", [
            { no: 1, name: "type", kind: "enum", T: () => ["rustplus.AppEntityType", AppEntityType] },
            { no: 3, name: "payload", kind: "message", T: () => AppEntityPayload }
        ]);
    }
    create(value?: PartialMessage<AppEntityInfo>): AppEntityInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<AppEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityInfo): AppEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* rustplus.AppEntityType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* rustplus.AppEntityPayload payload */ 3:
                    message.payload = AppEntityPayload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* rustplus.AppEntityType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* rustplus.AppEntityPayload payload = 3; */
        if (message.payload)
            AppEntityPayload.internalBinaryWrite(message.payload, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityInfo
 */
export const AppEntityInfo = new AppEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityPayload$Type extends MessageType<AppEntityPayload> {
    constructor() {
        super("rustplus.AppEntityPayload", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppEntityPayload_Item },
            { no: 3, name: "capacity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "hasProtection", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "protectionExpiry", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppEntityPayload>): AppEntityPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<AppEntityPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityPayload): AppEntityPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool value */ 1:
                    message.value = reader.bool();
                    break;
                case /* repeated rustplus.AppEntityPayload.Item items */ 2:
                    message.items.push(AppEntityPayload_Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 capacity */ 3:
                    message.capacity = reader.int32();
                    break;
                case /* optional bool hasProtection */ 4:
                    message.hasProtection = reader.bool();
                    break;
                case /* optional uint32 protectionExpiry */ 5:
                    message.protectionExpiry = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.Varint).bool(message.value);
        /* repeated rustplus.AppEntityPayload.Item items = 2; */
        for (let i = 0; i < message.items.length; i++)
            AppEntityPayload_Item.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 capacity = 3; */
        if (message.capacity !== undefined)
            writer.tag(3, WireType.Varint).int32(message.capacity);
        /* optional bool hasProtection = 4; */
        if (message.hasProtection !== undefined)
            writer.tag(4, WireType.Varint).bool(message.hasProtection);
        /* optional uint32 protectionExpiry = 5; */
        if (message.protectionExpiry !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.protectionExpiry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityPayload
 */
export const AppEntityPayload = new AppEntityPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityPayload_Item$Type extends MessageType<AppEntityPayload_Item> {
    constructor() {
        super("rustplus.AppEntityPayload.Item", [
            { no: 1, name: "itemId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "itemIsBlueprint", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppEntityPayload_Item>): AppEntityPayload_Item {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.itemId = 0;
        message.quantity = 0;
        message.itemIsBlueprint = false;
        if (value !== undefined)
            reflectionMergePartial<AppEntityPayload_Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityPayload_Item): AppEntityPayload_Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 itemId */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                case /* bool itemIsBlueprint */ 3:
                    message.itemIsBlueprint = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityPayload_Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 itemId = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        /* bool itemIsBlueprint = 3; */
        if (message.itemIsBlueprint !== false)
            writer.tag(3, WireType.Varint).bool(message.itemIsBlueprint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityPayload.Item
 */
export const AppEntityPayload_Item = new AppEntityPayload_Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamInfo$Type extends MessageType<AppTeamInfo> {
    constructor() {
        super("rustplus.AppTeamInfo", [
            { no: 1, name: "leaderSteamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppTeamInfo_Member },
            { no: 3, name: "mapNotes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppTeamInfo_Note },
            { no: 4, name: "leaderMapNotes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppTeamInfo_Note }
        ]);
    }
    create(value?: PartialMessage<AppTeamInfo>): AppTeamInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.leaderSteamId = 0n;
        message.members = [];
        message.mapNotes = [];
        message.leaderMapNotes = [];
        if (value !== undefined)
            reflectionMergePartial<AppTeamInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamInfo): AppTeamInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 leaderSteamId */ 1:
                    message.leaderSteamId = reader.uint64().toBigInt();
                    break;
                case /* repeated rustplus.AppTeamInfo.Member members */ 2:
                    message.members.push(AppTeamInfo_Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated rustplus.AppTeamInfo.Note mapNotes */ 3:
                    message.mapNotes.push(AppTeamInfo_Note.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated rustplus.AppTeamInfo.Note leaderMapNotes */ 4:
                    message.leaderMapNotes.push(AppTeamInfo_Note.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 leaderSteamId = 1; */
        if (message.leaderSteamId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.leaderSteamId);
        /* repeated rustplus.AppTeamInfo.Member members = 2; */
        for (let i = 0; i < message.members.length; i++)
            AppTeamInfo_Member.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated rustplus.AppTeamInfo.Note mapNotes = 3; */
        for (let i = 0; i < message.mapNotes.length; i++)
            AppTeamInfo_Note.internalBinaryWrite(message.mapNotes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated rustplus.AppTeamInfo.Note leaderMapNotes = 4; */
        for (let i = 0; i < message.leaderMapNotes.length; i++)
            AppTeamInfo_Note.internalBinaryWrite(message.leaderMapNotes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamInfo
 */
export const AppTeamInfo = new AppTeamInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamInfo_Member$Type extends MessageType<AppTeamInfo_Member> {
    constructor() {
        super("rustplus.AppTeamInfo.Member", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "isOnline", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "spawnTime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "isAlive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "deathTime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppTeamInfo_Member>): AppTeamInfo_Member {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamId = 0n;
        message.name = "";
        message.x = 0;
        message.y = 0;
        message.isOnline = false;
        message.spawnTime = 0;
        message.isAlive = false;
        message.deathTime = 0;
        if (value !== undefined)
            reflectionMergePartial<AppTeamInfo_Member>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamInfo_Member): AppTeamInfo_Member {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                case /* bool isOnline */ 5:
                    message.isOnline = reader.bool();
                    break;
                case /* uint32 spawnTime */ 6:
                    message.spawnTime = reader.uint32();
                    break;
                case /* bool isAlive */ 7:
                    message.isAlive = reader.bool();
                    break;
                case /* uint32 deathTime */ 8:
                    message.deathTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamInfo_Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1; */
        if (message.steamId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        /* bool isOnline = 5; */
        if (message.isOnline !== false)
            writer.tag(5, WireType.Varint).bool(message.isOnline);
        /* uint32 spawnTime = 6; */
        if (message.spawnTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.spawnTime);
        /* bool isAlive = 7; */
        if (message.isAlive !== false)
            writer.tag(7, WireType.Varint).bool(message.isAlive);
        /* uint32 deathTime = 8; */
        if (message.deathTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.deathTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamInfo.Member
 */
export const AppTeamInfo_Member = new AppTeamInfo_Member$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamInfo_Note$Type extends MessageType<AppTeamInfo_Note> {
    constructor() {
        super("rustplus.AppTeamInfo.Note", [
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AppTeamInfo_Note>): AppTeamInfo_Note {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<AppTeamInfo_Note>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamInfo_Note): AppTeamInfo_Note {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamInfo_Note, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamInfo.Note
 */
export const AppTeamInfo_Note = new AppTeamInfo_Note$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamMessage$Type extends MessageType<AppTeamMessage> {
    constructor() {
        super("rustplus.AppTeamMessage", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppTeamMessage>): AppTeamMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamId = 0n;
        message.name = "";
        message.message = "";
        message.color = "";
        message.time = 0;
        if (value !== undefined)
            reflectionMergePartial<AppTeamMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamMessage): AppTeamMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* string color */ 4:
                    message.color = reader.string();
                    break;
                case /* uint32 time */ 5:
                    message.time = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1; */
        if (message.steamId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* string color = 4; */
        if (message.color !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.color);
        /* uint32 time = 5; */
        if (message.time !== 0)
            writer.tag(5, WireType.Varint).uint32(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamMessage
 */
export const AppTeamMessage = new AppTeamMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamChat$Type extends MessageType<AppTeamChat> {
    constructor() {
        super("rustplus.AppTeamChat", [
            { no: 1, name: "messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppTeamMessage }
        ]);
    }
    create(value?: PartialMessage<AppTeamChat>): AppTeamChat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messages = [];
        if (value !== undefined)
            reflectionMergePartial<AppTeamChat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamChat): AppTeamChat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rustplus.AppTeamMessage messages */ 1:
                    message.messages.push(AppTeamMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamChat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rustplus.AppTeamMessage messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            AppTeamMessage.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamChat
 */
export const AppTeamChat = new AppTeamChat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMarker$Type extends MessageType<AppMarker> {
    constructor() {
        super("rustplus.AppMarker", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["rustplus.AppMarkerType", AppMarkerType] },
            { no: 3, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "steamId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "rotation", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "radius", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "color1", kind: "message", T: () => Vector4 },
            { no: 9, name: "color2", kind: "message", T: () => Vector4 },
            { no: 10, name: "alpha", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "outOfStock", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "sellOrders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppMarker_SellOrder }
        ]);
    }
    create(value?: PartialMessage<AppMarker>): AppMarker {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.type = 0;
        message.x = 0;
        message.y = 0;
        message.sellOrders = [];
        if (value !== undefined)
            reflectionMergePartial<AppMarker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMarker): AppMarker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* rustplus.AppMarkerType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* float x */ 3:
                    message.x = reader.float();
                    break;
                case /* float y */ 4:
                    message.y = reader.float();
                    break;
                case /* optional uint64 steamId */ 5:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                case /* optional float rotation */ 6:
                    message.rotation = reader.float();
                    break;
                case /* optional float radius */ 7:
                    message.radius = reader.float();
                    break;
                case /* optional rustplus.Vector4 color1 */ 8:
                    message.color1 = Vector4.internalBinaryRead(reader, reader.uint32(), options, message.color1);
                    break;
                case /* optional rustplus.Vector4 color2 */ 9:
                    message.color2 = Vector4.internalBinaryRead(reader, reader.uint32(), options, message.color2);
                    break;
                case /* optional float alpha */ 10:
                    message.alpha = reader.float();
                    break;
                case /* optional string name */ 11:
                    message.name = reader.string();
                    break;
                case /* optional bool outOfStock */ 12:
                    message.outOfStock = reader.bool();
                    break;
                case /* repeated rustplus.AppMarker.SellOrder sellOrders */ 13:
                    message.sellOrders.push(AppMarker_SellOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMarker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* rustplus.AppMarkerType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* float x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* float y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Bit32).float(message.y);
        /* optional uint64 steamId = 5; */
        if (message.steamId !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.steamId);
        /* optional float rotation = 6; */
        if (message.rotation !== undefined)
            writer.tag(6, WireType.Bit32).float(message.rotation);
        /* optional float radius = 7; */
        if (message.radius !== undefined)
            writer.tag(7, WireType.Bit32).float(message.radius);
        /* optional rustplus.Vector4 color1 = 8; */
        if (message.color1)
            Vector4.internalBinaryWrite(message.color1, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional rustplus.Vector4 color2 = 9; */
        if (message.color2)
            Vector4.internalBinaryWrite(message.color2, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional float alpha = 10; */
        if (message.alpha !== undefined)
            writer.tag(10, WireType.Bit32).float(message.alpha);
        /* optional string name = 11; */
        if (message.name !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.name);
        /* optional bool outOfStock = 12; */
        if (message.outOfStock !== undefined)
            writer.tag(12, WireType.Varint).bool(message.outOfStock);
        /* repeated rustplus.AppMarker.SellOrder sellOrders = 13; */
        for (let i = 0; i < message.sellOrders.length; i++)
            AppMarker_SellOrder.internalBinaryWrite(message.sellOrders[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMarker
 */
export const AppMarker = new AppMarker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMarker_SellOrder$Type extends MessageType<AppMarker_SellOrder> {
    constructor() {
        super("rustplus.AppMarker.SellOrder", [
            { no: 1, name: "itemId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "currencyId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "costPerItem", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "amountInStock", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "itemIsBlueprint", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "currencyIsBlueprint", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "itemCondition", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "itemConditionMax", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AppMarker_SellOrder>): AppMarker_SellOrder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.itemId = 0;
        message.quantity = 0;
        message.currencyId = 0;
        message.costPerItem = 0;
        message.amountInStock = 0;
        message.itemIsBlueprint = false;
        message.currencyIsBlueprint = false;
        if (value !== undefined)
            reflectionMergePartial<AppMarker_SellOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMarker_SellOrder): AppMarker_SellOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 itemId */ 1:
                    message.itemId = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                case /* int32 currencyId */ 3:
                    message.currencyId = reader.int32();
                    break;
                case /* int32 costPerItem */ 4:
                    message.costPerItem = reader.int32();
                    break;
                case /* int32 amountInStock */ 5:
                    message.amountInStock = reader.int32();
                    break;
                case /* bool itemIsBlueprint */ 6:
                    message.itemIsBlueprint = reader.bool();
                    break;
                case /* bool currencyIsBlueprint */ 7:
                    message.currencyIsBlueprint = reader.bool();
                    break;
                case /* optional float itemCondition */ 8:
                    message.itemCondition = reader.float();
                    break;
                case /* optional float itemConditionMax */ 9:
                    message.itemConditionMax = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMarker_SellOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 itemId = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).int32(message.itemId);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        /* int32 currencyId = 3; */
        if (message.currencyId !== 0)
            writer.tag(3, WireType.Varint).int32(message.currencyId);
        /* int32 costPerItem = 4; */
        if (message.costPerItem !== 0)
            writer.tag(4, WireType.Varint).int32(message.costPerItem);
        /* int32 amountInStock = 5; */
        if (message.amountInStock !== 0)
            writer.tag(5, WireType.Varint).int32(message.amountInStock);
        /* bool itemIsBlueprint = 6; */
        if (message.itemIsBlueprint !== false)
            writer.tag(6, WireType.Varint).bool(message.itemIsBlueprint);
        /* bool currencyIsBlueprint = 7; */
        if (message.currencyIsBlueprint !== false)
            writer.tag(7, WireType.Varint).bool(message.currencyIsBlueprint);
        /* optional float itemCondition = 8; */
        if (message.itemCondition !== undefined)
            writer.tag(8, WireType.Bit32).float(message.itemCondition);
        /* optional float itemConditionMax = 9; */
        if (message.itemConditionMax !== undefined)
            writer.tag(9, WireType.Bit32).float(message.itemConditionMax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMarker.SellOrder
 */
export const AppMarker_SellOrder = new AppMarker_SellOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppMapMarkers$Type extends MessageType<AppMapMarkers> {
    constructor() {
        super("rustplus.AppMapMarkers", [
            { no: 1, name: "markers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppMarker }
        ]);
    }
    create(value?: PartialMessage<AppMapMarkers>): AppMapMarkers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markers = [];
        if (value !== undefined)
            reflectionMergePartial<AppMapMarkers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppMapMarkers): AppMapMarkers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rustplus.AppMarker markers */ 1:
                    message.markers.push(AppMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppMapMarkers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rustplus.AppMarker markers = 1; */
        for (let i = 0; i < message.markers.length; i++)
            AppMarker.internalBinaryWrite(message.markers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppMapMarkers
 */
export const AppMapMarkers = new AppMapMarkers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppClanInfo$Type extends MessageType<AppClanInfo> {
    constructor() {
        super("rustplus.AppClanInfo", [
            { no: 1, name: "clanInfo", kind: "message", T: () => ClanInfo }
        ]);
    }
    create(value?: PartialMessage<AppClanInfo>): AppClanInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppClanInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppClanInfo): AppClanInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional rustplus.ClanInfo clanInfo */ 1:
                    message.clanInfo = ClanInfo.internalBinaryRead(reader, reader.uint32(), options, message.clanInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppClanInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional rustplus.ClanInfo clanInfo = 1; */
        if (message.clanInfo)
            ClanInfo.internalBinaryWrite(message.clanInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppClanInfo
 */
export const AppClanInfo = new AppClanInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppClanMessage$Type extends MessageType<AppClanMessage> {
    constructor() {
        super("rustplus.AppClanMessage", [
            { no: 1, name: "steamId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AppClanMessage>): AppClanMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamId = 0n;
        message.name = "";
        message.message = "";
        message.time = 0n;
        if (value !== undefined)
            reflectionMergePartial<AppClanMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppClanMessage): AppClanMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 steamId */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* int64 time */ 4:
                    message.time = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppClanMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 steamId = 1; */
        if (message.steamId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* int64 time = 4; */
        if (message.time !== 0n)
            writer.tag(4, WireType.Varint).int64(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppClanMessage
 */
export const AppClanMessage = new AppClanMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppClanChat$Type extends MessageType<AppClanChat> {
    constructor() {
        super("rustplus.AppClanChat", [
            { no: 1, name: "messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppClanMessage }
        ]);
    }
    create(value?: PartialMessage<AppClanChat>): AppClanChat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messages = [];
        if (value !== undefined)
            reflectionMergePartial<AppClanChat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppClanChat): AppClanChat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rustplus.AppClanMessage messages */ 1:
                    message.messages.push(AppClanMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppClanChat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rustplus.AppClanMessage messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            AppClanMessage.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppClanChat
 */
export const AppClanChat = new AppClanChat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppNexusAuth$Type extends MessageType<AppNexusAuth> {
    constructor() {
        super("rustplus.AppNexusAuth", [
            { no: 1, name: "serverId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playerToken", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppNexusAuth>): AppNexusAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverId = "";
        message.playerToken = 0;
        if (value !== undefined)
            reflectionMergePartial<AppNexusAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppNexusAuth): AppNexusAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string serverId */ 1:
                    message.serverId = reader.string();
                    break;
                case /* int32 playerToken */ 2:
                    message.playerToken = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppNexusAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string serverId = 1; */
        if (message.serverId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverId);
        /* int32 playerToken = 2; */
        if (message.playerToken !== 0)
            writer.tag(2, WireType.Varint).int32(message.playerToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppNexusAuth
 */
export const AppNexusAuth = new AppNexusAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppTeamChanged$Type extends MessageType<AppTeamChanged> {
    constructor() {
        super("rustplus.AppTeamChanged", [
            { no: 1, name: "playerId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "teamInfo", kind: "message", T: () => AppTeamInfo }
        ]);
    }
    create(value?: PartialMessage<AppTeamChanged>): AppTeamChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = 0n;
        if (value !== undefined)
            reflectionMergePartial<AppTeamChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppTeamChanged): AppTeamChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 playerId */ 1:
                    message.playerId = reader.uint64().toBigInt();
                    break;
                case /* rustplus.AppTeamInfo teamInfo */ 2:
                    message.teamInfo = AppTeamInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppTeamChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 playerId = 1; */
        if (message.playerId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.playerId);
        /* rustplus.AppTeamInfo teamInfo = 2; */
        if (message.teamInfo)
            AppTeamInfo.internalBinaryWrite(message.teamInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppTeamChanged
 */
export const AppTeamChanged = new AppTeamChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppNewTeamMessage$Type extends MessageType<AppNewTeamMessage> {
    constructor() {
        super("rustplus.AppNewTeamMessage", [
            { no: 1, name: "message", kind: "message", T: () => AppTeamMessage }
        ]);
    }
    create(value?: PartialMessage<AppNewTeamMessage>): AppNewTeamMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppNewTeamMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppNewTeamMessage): AppNewTeamMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* rustplus.AppTeamMessage message */ 1:
                    message.message = AppTeamMessage.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppNewTeamMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* rustplus.AppTeamMessage message = 1; */
        if (message.message)
            AppTeamMessage.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppNewTeamMessage
 */
export const AppNewTeamMessage = new AppNewTeamMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEntityChanged$Type extends MessageType<AppEntityChanged> {
    constructor() {
        super("rustplus.AppEntityChanged", [
            { no: 1, name: "entityId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "payload", kind: "message", T: () => AppEntityPayload }
        ]);
    }
    create(value?: PartialMessage<AppEntityChanged>): AppEntityChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = 0;
        if (value !== undefined)
            reflectionMergePartial<AppEntityChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEntityChanged): AppEntityChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entityId */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* rustplus.AppEntityPayload payload */ 2:
                    message.payload = AppEntityPayload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEntityChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entityId = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* rustplus.AppEntityPayload payload = 2; */
        if (message.payload)
            AppEntityPayload.internalBinaryWrite(message.payload, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppEntityChanged
 */
export const AppEntityChanged = new AppEntityChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppClanChanged$Type extends MessageType<AppClanChanged> {
    constructor() {
        super("rustplus.AppClanChanged", [
            { no: 1, name: "clanInfo", kind: "message", T: () => ClanInfo }
        ]);
    }
    create(value?: PartialMessage<AppClanChanged>): AppClanChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AppClanChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppClanChanged): AppClanChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional rustplus.ClanInfo clanInfo */ 1:
                    message.clanInfo = ClanInfo.internalBinaryRead(reader, reader.uint32(), options, message.clanInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppClanChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional rustplus.ClanInfo clanInfo = 1; */
        if (message.clanInfo)
            ClanInfo.internalBinaryWrite(message.clanInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppClanChanged
 */
export const AppClanChanged = new AppClanChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppNewClanMessage$Type extends MessageType<AppNewClanMessage> {
    constructor() {
        super("rustplus.AppNewClanMessage", [
            { no: 1, name: "clanId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "message", kind: "message", T: () => AppClanMessage }
        ]);
    }
    create(value?: PartialMessage<AppNewClanMessage>): AppNewClanMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clanId = 0n;
        if (value !== undefined)
            reflectionMergePartial<AppNewClanMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppNewClanMessage): AppNewClanMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 clanId */ 1:
                    message.clanId = reader.int64().toBigInt();
                    break;
                case /* rustplus.AppClanMessage message */ 2:
                    message.message = AppClanMessage.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppNewClanMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 clanId = 1; */
        if (message.clanId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.clanId);
        /* rustplus.AppClanMessage message = 2; */
        if (message.message)
            AppClanMessage.internalBinaryWrite(message.message, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppNewClanMessage
 */
export const AppNewClanMessage = new AppNewClanMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCameraSubscribe$Type extends MessageType<AppCameraSubscribe> {
    constructor() {
        super("rustplus.AppCameraSubscribe", [
            { no: 1, name: "cameraId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppCameraSubscribe>): AppCameraSubscribe {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cameraId = "";
        if (value !== undefined)
            reflectionMergePartial<AppCameraSubscribe>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCameraSubscribe): AppCameraSubscribe {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cameraId */ 1:
                    message.cameraId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCameraSubscribe, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cameraId = 1; */
        if (message.cameraId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cameraId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppCameraSubscribe
 */
export const AppCameraSubscribe = new AppCameraSubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCameraInput$Type extends MessageType<AppCameraInput> {
    constructor() {
        super("rustplus.AppCameraInput", [
            { no: 1, name: "buttons", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "mouseDelta", kind: "message", T: () => Vector2 }
        ]);
    }
    create(value?: PartialMessage<AppCameraInput>): AppCameraInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buttons = 0;
        if (value !== undefined)
            reflectionMergePartial<AppCameraInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCameraInput): AppCameraInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 buttons */ 1:
                    message.buttons = reader.int32();
                    break;
                case /* rustplus.Vector2 mouseDelta */ 2:
                    message.mouseDelta = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.mouseDelta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCameraInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 buttons = 1; */
        if (message.buttons !== 0)
            writer.tag(1, WireType.Varint).int32(message.buttons);
        /* rustplus.Vector2 mouseDelta = 2; */
        if (message.mouseDelta)
            Vector2.internalBinaryWrite(message.mouseDelta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppCameraInput
 */
export const AppCameraInput = new AppCameraInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCameraInfo$Type extends MessageType<AppCameraInfo> {
    constructor() {
        super("rustplus.AppCameraInfo", [
            { no: 1, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "nearPlane", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "farPlane", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "controlFlags", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AppCameraInfo>): AppCameraInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        message.nearPlane = 0;
        message.farPlane = 0;
        message.controlFlags = 0;
        if (value !== undefined)
            reflectionMergePartial<AppCameraInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCameraInfo): AppCameraInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 width */ 1:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 2:
                    message.height = reader.int32();
                    break;
                case /* float nearPlane */ 3:
                    message.nearPlane = reader.float();
                    break;
                case /* float farPlane */ 4:
                    message.farPlane = reader.float();
                    break;
                case /* int32 controlFlags */ 5:
                    message.controlFlags = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCameraInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).int32(message.width);
        /* int32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).int32(message.height);
        /* float nearPlane = 3; */
        if (message.nearPlane !== 0)
            writer.tag(3, WireType.Bit32).float(message.nearPlane);
        /* float farPlane = 4; */
        if (message.farPlane !== 0)
            writer.tag(4, WireType.Bit32).float(message.farPlane);
        /* int32 controlFlags = 5; */
        if (message.controlFlags !== 0)
            writer.tag(5, WireType.Varint).int32(message.controlFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppCameraInfo
 */
export const AppCameraInfo = new AppCameraInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCameraRays$Type extends MessageType<AppCameraRays> {
    constructor() {
        super("rustplus.AppCameraRays", [
            { no: 1, name: "verticalFov", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "sampleOffset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "rayData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "distance", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "entities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppCameraRays_Entity }
        ]);
    }
    create(value?: PartialMessage<AppCameraRays>): AppCameraRays {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.verticalFov = 0;
        message.sampleOffset = 0;
        message.rayData = new Uint8Array(0);
        message.distance = 0;
        message.entities = [];
        if (value !== undefined)
            reflectionMergePartial<AppCameraRays>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCameraRays): AppCameraRays {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float verticalFov */ 1:
                    message.verticalFov = reader.float();
                    break;
                case /* int32 sampleOffset */ 2:
                    message.sampleOffset = reader.int32();
                    break;
                case /* bytes rayData */ 3:
                    message.rayData = reader.bytes();
                    break;
                case /* float distance */ 4:
                    message.distance = reader.float();
                    break;
                case /* repeated rustplus.AppCameraRays.Entity entities */ 5:
                    message.entities.push(AppCameraRays_Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCameraRays, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float verticalFov = 1; */
        if (message.verticalFov !== 0)
            writer.tag(1, WireType.Bit32).float(message.verticalFov);
        /* int32 sampleOffset = 2; */
        if (message.sampleOffset !== 0)
            writer.tag(2, WireType.Varint).int32(message.sampleOffset);
        /* bytes rayData = 3; */
        if (message.rayData.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.rayData);
        /* float distance = 4; */
        if (message.distance !== 0)
            writer.tag(4, WireType.Bit32).float(message.distance);
        /* repeated rustplus.AppCameraRays.Entity entities = 5; */
        for (let i = 0; i < message.entities.length; i++)
            AppCameraRays_Entity.internalBinaryWrite(message.entities[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppCameraRays
 */
export const AppCameraRays = new AppCameraRays$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppCameraRays_Entity$Type extends MessageType<AppCameraRays_Entity> {
    constructor() {
        super("rustplus.AppCameraRays.Entity", [
            { no: 1, name: "entityId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["rustplus.AppCameraRays.EntityType", AppCameraRays_EntityType] },
            { no: 3, name: "position", kind: "message", T: () => Vector3 },
            { no: 4, name: "rotation", kind: "message", T: () => Vector3 },
            { no: 5, name: "size", kind: "message", T: () => Vector3 },
            { no: 6, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppCameraRays_Entity>): AppCameraRays_Entity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = 0;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<AppCameraRays_Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppCameraRays_Entity): AppCameraRays_Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entityId */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* rustplus.AppCameraRays.EntityType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* rustplus.Vector3 position */ 3:
                    message.position = Vector3.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* rustplus.Vector3 rotation */ 4:
                    message.rotation = Vector3.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* rustplus.Vector3 size */ 5:
                    message.size = Vector3.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                case /* optional string name */ 6:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppCameraRays_Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entityId = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* rustplus.AppCameraRays.EntityType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* rustplus.Vector3 position = 3; */
        if (message.position)
            Vector3.internalBinaryWrite(message.position, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* rustplus.Vector3 rotation = 4; */
        if (message.rotation)
            Vector3.internalBinaryWrite(message.rotation, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* rustplus.Vector3 size = 5; */
        if (message.size)
            Vector3.internalBinaryWrite(message.size, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string name = 6; */
        if (message.name !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rustplus.AppCameraRays.Entity
 */
export const AppCameraRays_Entity = new AppCameraRays_Entity$Type();
